# 레디스 조회 Polling API -> Websocket 개선 보고서 


## 개요

이 보고서는 크게 3가지 파트로 구성됩니다.
  
**1) 콘서트 예약 서비스의 두 가지 기능 - 대기 번호 조회, 5분간 좌석 선점** <br>
**2) 문제 정의** <br>
**3) 3가지 락 구현** <br>
**4) 3가지 락 동시성 통합 테스트 구현** <br>
**5) 결론** <br> 
**6) 앞으로 고민할 포인트** <br> 

<br> 

## 1) 콘서트 예약 서비스의 두 가지 기능 - 대기번호 조회, 5분간 좌석 선점
- **콘서트 예약 서비스**에는  대기번호를 조회하고고, 동시에 5분간 좌석을 선점하는 두 가지 중요한 기능이 있습니다 <br>

<br> 

**(1) 대기 번호 조회**
- **목적**: 대기열을 통해 사용자가 자신의 예약 가능 시간을 파악할 수 있도록 돕는 기능입니다. <br> 
- **설명**
  많은 사용자가 몰리는 경우, 일부 사용자는 대기하게 되며, 이때 **대기 번호**를 통해 예약 가능 시점을 예측할 수 있습니다. <br> 
  주기적인 대기 번호 조회는 사용자가 자신의 예약 가능 시점을 알 수 있게 해주어, <br>
  서비스의 투명성을 높이고, 예측 가능성을 제공합니다. <br> 

- **기술적 관리 방식: Polling API** <br> 
  사용자가 **주기적으로 대기 번호를 조회**할 수 있도록 하기 위해 **Polling API** 방식을 사용합니다. <br>

  
<br> 


**(2) 5분간 좌석 선점**
- **목적**: 사용자가 예약 시 좌석을 선점해 다른 사용자의 중복 예약을 방지하고, 결제 과정에서의 문제를 예방하는 기능입니다. <br> 
- **설명**:
  **대기열에서 활성화된 사용자**는 **5분 동안 좌석을 선점**할 수 있습니다. <br> 
  **5분간 좌석 선점** 기능은 여러 사용자가 동시에 같은 좌석을 예약하려고 할 때 발생할 수 있는 **결제 과정 중의 충돌**을 방지하기 위해 도입되었습니다. <br>
  이 기능을 통해, 결제 단계에서 **한 명의 사용자만 결제**를 진행할 수 있게 하여 **사용자 경험을 개선**합니다. <br> 

- **기술적 관리 방식: Redis 분산 락** <br> 
  **Redis 분산 락**을 사용하여 좌석 선점 기능을 관리합니다. <br>
  이 방식은 **여러 사용자가 동시에 같은 좌석**을 예약하려는 경쟁 상황에서 **경쟁 상태를 안전하게 처리**할 수 있게 도와줍니다.


<br>


## 2) 문제 정의 

- 그런데 두 기능은 각각 다음과 같은 문제점을 갖고 있습니다.

<br>

**(1) 대기 번호 조회**
- **문제점: 주기적인 Polling API 호출로 인한 서버 부하** <br>
- 사용자가 대기 번호를 조회하기 위해 **주기적으로 Polling API**를 호출해야 합니다. <br> 
- 예를 들어, **10만 명**의 사용자가 대기하고 있을 경우, 10초마다 1번씩 대기 번호를 조회한다면, **10초마다 10만 번의 Polling API 호출**이 발생합니다. <br>
- 이 대량의 API 호출은 **서버 CPU 자원에 심각한 부하**를 주게 되며, 특히 트래픽이 몰리는 시점에서는 **서버 성능 저하**를 초래할 수 있습니다 <br>

**(2) 5분간 좌석 선점**
- **문제점: 이탈한 사용자의 관리와 Redis 락 해제**
- 사용자가 **5분간 좌석 선점**을 시작한 후, 중간에 이탈하는 경우(예: 1분 후) 해당 좌석은 **Redis 분산 락**에 의해 잠겨 있는 상태입니다. <br>
- 이 경우, **다른 사용자가 예약을 시도**하려면 먼저 락을 해제해야 하는데, 이탈한 사용자가 **언제 이탈했는지 확인**하는 문제가 발생합니다. <br>
- 사용자가 이탈했음을 추적하기 위해 **별도의 Polling API** 또는 기타 장치가 필요합니다. <br> 
- 예를 들어, 사용자가 좌석 선점을 시작한 후 **주기적으로 Polling API**를 호출하여, 사용자가 더 이상 호출하지 않으면 이탈한 것으로 간주할 수 있습니다. <br>
- 하지만 이 방식은 서버가 **사용자 상태를 주기적으로 관리**해야 하므로, **관리의 복잡성과 불필요한 리소스 소모**를 초래할 수 있습니다. <br>





   


