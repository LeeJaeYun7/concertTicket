

# '최근 3일간 판매량 Top30 콘서트' 조회 시 인덱스 도입 보고서 

## 개요

이 보고서는 크게 4가지 파트로 구성됩니다.
  
**1) 인덱스 도입 이유** <br>
**2) 인덱스 도입 과정** <br>
**3) 인덱스 구현** <br>
**4) 인덱스 도입을 통해 개선된 점** <br> 

<br>


### 1) 인덱스 도입 이유
- 콘서트 티켓 서비스에서는 예약, 결제 등과 같은 중요한 데이터들이 지속적으로 데이터베이스에 저장됩니다. <br>
  이러한 데이터가 **대용량**(예: 수백만 건 이상)으로 누적되면, 데이터베이스 조회 시 높은 **응답 시간**이 발생할 수 있습니다. <br>
  이로 인해 서비스 성능이 저하될 위험이 있습니다. <br>

- 따라서, 대용량 데이터를 효율적으로 처리하고, 낮은 **응답 시간**을 제공하기 위해 <br>
  데이터베이스 인덱스를 도입하여 서비스 성능을 최적화하는 것을 목표로 했습니다. <br> 


<br> 

### 2) 인덱스 도입 과정
![image](https://github.com/user-attachments/assets/6d559890-32af-4873-b844-c74d5177a286)

#### (1) 인덱스 도입 기능 선택

- 콘서트 티켓 서비스에서는 **최근 3일간 판매량 Top30 콘서트**라는 기능을 제공합니다. <br>
  이 기능은 메인 페이지에서 제공되므로, 다수의 사용자에게 자주 조회되는 기능입니다. <br>

- 해당 기능은 DB의 **예약 테이블**을 조회하여 제공되는데, <br>
  예약 데이터가 대용량 데이터가 되는 경우 **Table Full Scan**으로 조회 시 성능 저하가 발생할 수 있습니다. <br> 

- 이를 해결하기 위해 **최근 3일간 판매량 Top30 콘서트** 기능에 적절한 인덱스를 도입하여, <br>
  DB 조회 성능을 개선할 필요성이 있다고 판단했습니다.

<br> 

#### (2) 인덱스 도입 시 고려한 점
- 인덱스 도입 시, 고려할 점은 크게 2가지입니다. <br>
  (2-1) 단일 인덱스 vs 복합 인덱스 <br> 
  (2-2) 테이블의 어떤 필드들을 인덱스로 선택할지 <br>

<br> 
  
#### (2-1) 단일 인덱스 vs 복합 인덱스 

| 특성              | **단일 인덱스**                           | **복합 인덱스**                              |
|-------------------|------------------------------------------|--------------------------------------------|
| **적용 대상**      | 하나의 컬럼만 사용                       | 여러 컬럼을 함께 사용                      |
| **성능 최적화**    | 단일 컬럼에 대한 검색 최적화             | 여러 컬럼을 결합한 조건에 최적화            |
| **공간 사용**      | 적은 공간을 사용                         | 더 많은 공간을 사용                        |
| **업데이트 성능**  | 인덱스 업데이트가 빠름                   | 인덱스 업데이트가 느릴 수 있음             |
| **사용 예시**      | 단일 컬럼 검색, 범위 검색                | 여러 컬럼에 대한 검색 조건이 포함된 쿼리    |

- 인덱스를 생성할 때 **칼럼을 추가**하는 것은 조회 성능을 향상시킬 수 있으나, <br>
  **업데이트**나 **삭제** 성능에 부정적인 영향을 미칠 수 있고, **메모리 공간**을 더 많이 사용합니다. <br>
  이러한 **Trade-off**를 잘 고려해서 의사결정해야 합니다. <br> 

<br>


#### (2-2) 테이블의 어떤 필드들을 인덱스로 선택할지

| **카디널리티가 높은 필드**                     | **카디널리티가 낮은 필드**                     |
|-----------------------------------------------|-----------------------------------------------|
| 검색 범위가 좁혀져 빠르게 결과를 찾을 수 있음 | 검색 범위가 여전히 크므로 인덱스 효과가 적음  |
| 고유한 값들이 많아 인덱스가 매우 효율적임     | 반복되는 값들이 많아 인덱스 효과가 미미함     |

- 인덱스를 생성할 때는, **카디널리티**(Cardinality)가 높은 필드를 선택하는 것이 권장됩니다. <br>
  카디널리티는 특정 칼럼에 존재하는 **고유 값의 개수**를 의미합니다. <br> 
  카디널리티가 높은 필드는 **검색 범위가 좁아지기** 때문에 인덱스의 효과가 더 크게 나타납니다. <br>


<br>


#### (2-3) 예약 테이블 DDL & 조회 쿼리 

- 현재 인덱스 도입을 결정한 **예약 테이블의 DDL**과 **조회 쿼리**는 다음과 같습니다.

#### 예약 테이블의 DDL
| **컬럼명**              | **데이터 타입**      | **NULL 허용** | **키**   | **기타**        |
|-------------------------|----------------------|---------------|----------|-----------------|
| `id`                    | `bigint`             | `NO`          | `PRI`    | `auto_increment`|
| `created_at`             | `datetime(6)`        | `YES`         |          |                 |
| `updated_at`             | `datetime(6)`        | `YES`         |          |                 |
| `price`                  | `bigint`             | `NO`          |          |                 |
| `uuid`                   | `varchar(255)`       | `YES`         |          |                 |
| `seat_id`                | `bigint`             | `YES`         | `MUL`    |                 |
| `concert_schedule_id`    | `bigint`             | `YES`         | `MUL`    |                 |
| `concert_id`             | `bigint`             | `YES`         | `MUL`    |                 |


#### 조회 쿼리
```
SELECT c.*, r.salesCount
FROM Concert c
JOIN (
    SELECT r.concert_id AS concertId, COUNT(*) AS salesCount
    FROM Reservation r
    WHERE r.created_at >= NOW() - INTERVAL 3 DAY  -- 현재 시각 기준으로 3일 전
    GROUP BY r.concert_id
) AS r ON c.id = r.concertId
ORDER BY r.salesCount DESC
LIMIT 30;
```

#### 조회 쿼리 분석 
```

```



#### (2-4) 결론

- 예약 테이블의 DDL과 조회 쿼리를 고려할 때, **created_at과 concert_id 필드에 복합 인덱스를 적용**하기로 결정했습니다.

(1) **created_at 필드**는 조회 쿼리의 WHERE 절에서 자주 사용되며, 카디널리티가 높은 필드로 데이터 분포가 균일합니다. <br>
    따라서 이 필드를 인덱싱하면 조회 성능을 크게 향상시킬 수 있습니다. <br>
    
(2) **concert_id 필드**를 추가하여 복합 인덱스를 구성함으로써, 특정 콘서트에 대한 예약을 효율적으로 조회할 수 있도록 최적화했습니다. <br> 
    이로 인해 created_at과 concert_id가 함께 사용되는 조회 쿼리의 성능이 더욱 개선될 것입니다. <br> 


<br> 

### 3) 인덱스 구현

- 콘서트 티켓 서비스에서는 JPA를 활용하므로, JPA의 **@Index 어노테이션**을 활용해서 인덱스를 구현했습니다. <br> 
  
![image](https://github.com/user-attachments/assets/a396a5cf-e8d1-481d-b4e4-17f715730556)

<br> 


### 4) 인덱스 도입을 통해 개선된 점

- 현재 예약 테이블에는 **26만 row**의 데이터가 적재되어 있습니다
  ![image](https://github.com/user-attachments/assets/d73a3a03-f0e4-4980-b8f0-0546bb86d14f)

<br> 

- 예약 테이블과 콘서트 테이블을 JOIN해서 **'최근 3일간 판매량 Top30 콘서트'를 조회**해서 <br>
  **판매량 기준 내림차순 정렬**하면 다음과 같은 결과를 얻을 수 있습니다.
![image](https://github.com/user-attachments/assets/a67c61c5-0bc3-47a7-ab2b-42c639882f71)


**'최근 3일간 Top30 콘서트'** 정보를 불러오는 작업에 대해 k6를 사용하여 2가지 테스트를 진행했습니다: <br> 
(1) 인덱스 없이 조회 쿼리 <br>
(2) 인덱스 포함 조회 쿼리 <br> 

k6 테스트 조건은 다음과 같습니다 <br> 
(1) 60초 동안 1,000건의 요청 발생 <br> 
(2) P90, P95, P99 지연시간 측정 <br> 
(3) P99 지연시간의 threshold는 1초로 설정 <br> 

**(1) 인덱스 없이 조회 쿼리**

- 로컬 환경에서 **K6**으로 테스트 시 다음과 같은 결과를 얻었습니다. <br>

![image](https://github.com/user-attachments/assets/b7d446a5-4cb8-440e-a7b0-0f3439197f5f)


**(2) 인덱스 포함 조회 쿼리** 

- 로컬 환경에서 **K6**으로 테스트 시 다음과 같은 결과를 얻었습니다. <br>

![image](https://github.com/user-attachments/assets/f62fea8a-2cae-43e2-8175-9cba93bdef86)


